const express = require('express');
const { Pool } = require('pg');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3050;
const IS_TEST = process.env.NODE_ENV === 'test';

// Middleware para parsing JSON com limite de tamanho
app.use(express.json({ limit: '10mb' }));

// Middleware para CORS (se necess√°rio para frontend)
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});

// Configura√ß√£o da conex√£o PostgreSQL com melhor tratamento de erros
const pool = new Pool({
  host: process.env.DB_HOST,
  port: process.env.DB_PORT || 5432,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  ssl: process.env.NODE_ENV === 'production' ? {
    rejectUnauthorized: false
  } : false,
  connectionTimeoutMillis: 15000, // 15 segundos
  idleTimeoutMillis: 30000, // 30 segundos
  max: 20, // m√°ximo de conex√µes no pool
  min: 2, // m√≠nimo de conex√µes
  allowExitOnIdle: true
});

// Teste de conex√£o inicial com retry melhorado
const testConnection = async () => {
  const maxRetries = 5;
  let retries = maxRetries;
  
  while (retries > 0) {
    try {
      const client = await pool.connect();
      await client.query('SELECT NOW()'); // Teste simples
      console.log('‚úÖ Conectado ao PostgreSQL com sucesso!');
      client.release();
      return true;
    } catch (err) {
      console.log(`‚ùå Tentativa de conex√£o falhou. Tentativas restantes: ${retries - 1}`);
      console.error('Erro:', err.message);
      retries--;
      
      if (retries > 0) {
        const delay = Math.min(1000 * (maxRetries - retries + 1), 10000); // Backoff exponencial
        console.log(`üîÑ Tentando novamente em ${delay/1000} segundos...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
  }
  
  console.error('‚ùå N√£o foi poss√≠vel conectar ao PostgreSQL ap√≥s todas as tentativas');
  console.log('üìã Verifique suas credenciais no arquivo .env');
  return false;
};

// Fun√ß√£o utilit√°ria para calcular m√©dia final com valida√ß√£o
const calculateFinalAverage = (firstSemester, secondSemester) => {
  const first = parseFloat(firstSemester);
  const second = parseFloat(secondSemester);
  
  if (isNaN(first) || isNaN(second)) {
    throw new Error('Notas devem ser n√∫meros v√°lidos');
  }
  
  return Math.round(((first + second) / 2) * 100) / 100; // Arredonda para 2 casas decimais
};

// Middleware para valida√ß√£o de UUID melhorado
const validateUUID = (req, res, next) => {
  const { id } = req.params;
  
  if (!id) {
    return res.status(400).json({ error: 'ID √© obrigat√≥rio' });
  }
  
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  
  if (!uuidRegex.test(id)) {
    return res.status(400).json({ error: 'ID deve ser um UUID v√°lido' });
  }
  
  next();
};

// Middleware para valida√ß√£o de dados do participante
const validateParticipantData = (req, res, next) => {
  const { full_name, age, first_semester, second_semester } = req.body;
  const errors = [];
  
  // Valida√ß√£o de nome
  if (full_name !== undefined) {
    if (typeof full_name !== 'string' || full_name.trim().length === 0) {
      errors.push('full_name deve ser uma string n√£o vazia');
    } else if (full_name.trim().length > 255) {
      errors.push('full_name deve ter no m√°ximo 255 caracteres');
    }
  }
  
  // Valida√ß√£o de idade
  if (age !== undefined) {
    if (!Number.isInteger(age) || age <= 0 || age > 150) {
      errors.push('age deve ser um n√∫mero inteiro entre 1 e 150');
    }
  }
  
  // Valida√ß√£o de notas
  if (first_semester !== undefined) {
    if (typeof first_semester !== 'number' || first_semester < 0 || first_semester > 10) {
      errors.push('first_semester deve ser um n√∫mero entre 0 e 10');
    }
  }
  
  if (second_semester !== undefined) {
    if (typeof second_semester !== 'number' || second_semester < 0 || second_semester > 10) {
      errors.push('second_semester deve ser um n√∫mero entre 0 e 10');
    }
  }
  
  if (errors.length > 0) {
    return res.status(400).json({ error: 'Dados inv√°lidos', details: errors });
  }
  
  next();
};

// Middleware para logging de requisi√ß√µes
const requestLogger = (req, res, next) => {
  if (!IS_TEST) {
    console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  }
  next();
};

app.use(requestLogger);

// ENDPOINTS CRUD

// GET /api/participants - Lista todos os participantes com pagina√ß√£o opcional
app.get('/api/participants', async (req, res) => {
  let client;
  try {
    // Par√¢metros de pagina√ß√£o
    const page = parseInt(req.query.page) || 1;
    const limit = Math.min(parseInt(req.query.limit) || 50, 100); // M√°ximo 100 por p√°gina
    const offset = (page - 1) * limit;
    
    // Par√¢metros de ordena√ß√£o
    const sortBy = req.query.sortBy || 'full_name';
    const sortOrder = req.query.sortOrder === 'desc' ? 'DESC' : 'ASC';
    const allowedSortFields = ['full_name', 'age', 'final_average', 'first_semester', 'second_semester'];
    
    if (!allowedSortFields.includes(sortBy)) {
      return res.status(400).json({ error: 'Campo de ordena√ß√£o inv√°lido' });
    }
    
    client = await pool.connect();
    
    // Query principal com pagina√ß√£o
    const query = `
      SELECT * FROM participants 
      ORDER BY ${sortBy} ${sortOrder} 
      LIMIT $1 OFFSET $2
    `;
    
    const result = await client.query(query, [limit, offset]);
    
    // Query para contar total de registros
    const countResult = await client.query('SELECT COUNT(*) FROM participants');
    const totalCount = parseInt(countResult.rows[0].count);
    
    res.status(200).json({
      data: result.rows,
      pagination: {
        page,
        limit,
        total: totalCount,
        totalPages: Math.ceil(totalCount / limit)
      }
    });
  } catch (error) {
    console.error('Erro ao buscar participantes:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  } finally {
    if (client) client.release();
  }
});

// GET /api/participants/:id - Busca participante por ID
app.get('/api/participants/:id', validateUUID, async (req, res) => {
  let client;
  try {
    const { id } = req.params;
    
    client = await pool.connect();
    const result = await client.query('SELECT * FROM participants WHERE id = $1', [id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Participante n√£o encontrado' });
    }
    
    res.status(200).json(result.rows[0]);
  } catch (error) {
    console.error('Erro ao buscar participante:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  } finally {
    if (client) client.release();
  }
});

// POST /api/participants - Cria novo participante
app.post('/api/participants', validateParticipantData, async (req, res) => {
  let client;
  try {
    const { full_name, age, first_semester, second_semester } = req.body;
    
    // Valida√ß√£o dos campos obrigat√≥rios
    if (!full_name || age === undefined || first_semester === undefined || second_semester === undefined) {
      return res.status(400).json({ 
        error: 'Campos obrigat√≥rios: full_name, age, first_semester, second_semester' 
      });
    }
    
    // Normaliza o nome
    const normalizedName = full_name.trim();
    
    // Calcula a m√©dia final
    let final_average;
    try {
      final_average = calculateFinalAverage(first_semester, second_semester);
    } catch (error) {
      return res.status(400).json({ error: error.message });
    }
    
    client = await pool.connect();
    
    // Verifica se j√° existe participante com o mesmo nome
    const existingCheck = await client.query(
      'SELECT id FROM participants WHERE LOWER(full_name) = LOWER($1)',
      [normalizedName]
    );
    
    if (existingCheck.rows.length > 0) {
      return res.status(409).json({ error: 'J√° existe um participante com este nome' });
    }
    
    // Insere no banco de dados
    const result = await client.query(
      `INSERT INTO participants (id, full_name, age, first_semester, second_semester, final_average) 
       VALUES (gen_random_uuid(), $1, $2, $3, $4, $5) 
       RETURNING *`,
      [normalizedName, age, first_semester, second_semester, final_average]
    );
    
    res.status(201).json(result.rows[0]);
  } catch (error) {
    console.error('Erro ao criar participante:', error);
    if (error.code === '23505') { // Viola√ß√£o de constraint unique
      res.status(409).json({ error: 'Participante j√° existe' });
    } else {
      res.status(500).json({ error: 'Erro interno do servidor' });
    }
  } finally {
    if (client) client.release();
  }
});

// PUT /api/participants/:id - Atualiza participante existente
app.put('/api/participants/:id', validateUUID, validateParticipantData, async (req, res) => {
  let client;
  try {
    const { id } = req.params;
    const { full_name, age, first_semester, second_semester } = req.body;
    
    client = await pool.connect();
    
    // Verifica se o participante existe
    const existingParticipant = await client.query('SELECT * FROM participants WHERE id = $1', [id]);
    if (existingParticipant.rows.length === 0) {
      return res.status(404).json({ error: 'Participante n√£o encontrado' });
    }
    
    const current = existingParticipant.rows[0];
    
    // Prepara os campos para atualiza√ß√£o (mant√©m valores atuais se n√£o fornecidos)
    const updatedName = full_name !== undefined ? full_name.trim() : current.full_name;
    const updatedAge = age !== undefined ? age : current.age;
    const updatedFirstSemester = first_semester !== undefined ? first_semester : current.first_semester;
    const updatedSecondSemester = second_semester !== undefined ? second_semester : current.second_semester;
    
    // Verifica se o novo nome j√° existe em outro participante
    if (full_name !== undefined && full_name.trim().toLowerCase() !== current.full_name.toLowerCase()) {
      const nameCheck = await client.query(
        'SELECT id FROM participants WHERE LOWER(full_name) = LOWER($1) AND id != $2',
        [updatedName, id]
      );
      
      if (nameCheck.rows.length > 0) {
        return res.status(409).json({ error: 'J√° existe outro participante com este nome' });
      }
    }
    
    // Recalcula a m√©dia final
    let final_average;
    try {
      final_average = calculateFinalAverage(updatedFirstSemester, updatedSecondSemester);
    } catch (error) {
      return res.status(400).json({ error: error.message });
    }
    
    // Atualiza no banco de dados
    const result = await client.query(
      `UPDATE participants 
       SET full_name = $1, age = $2, first_semester = $3, second_semester = $4, final_average = $5 
       WHERE id = $6 
       RETURNING *`,
      [updatedName, updatedAge, updatedFirstSemester, updatedSecondSemester, final_average, id]
    );
    
    res.status(200).json(result.rows[0]);
  } catch (error) {
    console.error('Erro ao atualizar participante:', error);
    if (error.code === '23505') {
      res.status(409).json({ error: 'Nome j√° existe para outro participante' });
    } else {
      res.status(500).json({ error: 'Erro interno do servidor' });
    }
  } finally {
    if (client) client.release();
  }
});

// DELETE /api/participants/:id - Remove participante
app.delete('/api/participants/:id', validateUUID, async (req, res) => {
  let client;
  try {
    const { id } = req.params;
    
    client = await pool.connect();
    const result = await client.query('DELETE FROM participants WHERE id = $1 RETURNING id', [id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Participante n√£o encontrado' });
    }
    
    res.status(204).send(); // No Content - sucesso sem retorno de dados
  } catch (error) {
    console.error('Erro ao deletar participante:', error);
    res.status(500).json({ error: 'Erro interno do servidor' });
  } finally {
    if (client) client.release();
  }
});

// GET /api/health - Health check endpoint
app.get('/api/health', async (req, res) => {
  try {
    const client = await pool.connect();
    await client.query('SELECT 1');
    client.release();
    
    res.status(200).json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      database: 'connected'
    });
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      database: 'disconnected',
      error: error.message
    });
  }
});

// Middleware para rotas n√£o encontradas
app.use((req, res) => {
  res.status(404).json({ 
    error: 'Rota n√£o encontrada',
    path: req.path,
    method: req.method
  });
});

// Middleware global de tratamento de erros
app.use((error, req, res, next) => {
  console.error('Erro n√£o tratado:', error);
  
  // Erro de JSON malformado
  if (error instanceof SyntaxError && error.status === 400 && 'body' in error) {
    return res.status(400).json({ error: 'JSON inv√°lido no corpo da requisi√ß√£o' });
  }
  
  res.status(500).json({ 
    error: 'Erro interno do servidor',
    timestamp: new Date().toISOString()
  });
});

// Inicia o servidor
if (!IS_TEST) {
  testConnection().then((connected) => {
    if (connected) {
      app.listen(PORT, () => {
        console.log(`üöÄ Servidor rodando na porta ${PORT}`);
        console.log(`üìä Health check dispon√≠vel em http://localhost:${PORT}/api/health`);
      });
    } else {
      console.error('‚ùå N√£o foi poss√≠vel iniciar o servidor devido a problemas de conex√£o');
      process.exit(1);
    }
  });
}

// Graceful shutdown melhorado
const gracefulShutdown = async (signal) => {
  console.log(`\nüì° Recebido sinal ${signal}. Encerrando servidor graciosamente...`);
  
  try {
    await pool.end();
    console.log('‚úÖ Pool de conex√µes encerrado');
    console.log('üëã Servidor encerrado com sucesso');
    process.exit(0);
  } catch (error) {
    console.error('‚ùå Erro durante o encerramento:', error);
    process.exit(1);
  }
};

process.on('SIGINT', () => gracefulShutdown('SIGINT'));
process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));

// Tratamento de erros n√£o capturados
process.on('unhandledRejection', (reason, promise) => {
  console.error('üö® Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (error) => {
  console.error('üö® Uncaught Exception:', error);
  gracefulShutdown('UNCAUGHT_EXCEPTION');
});

module.exports = app;

/*
MELHORIAS IMPLEMENTADAS:

1. üîí VALIDA√á√ÉO ROBUSTA:
   - Valida√ß√£o de UUID mais rigorosa
   - Valida√ß√£o de dados de entrada completa
   - Valida√ß√£o de limites (idade 1-150, notas 0-10)
   - Valida√ß√£o de tamanho de string (nome at√© 255 chars)

2. üöÄ PERFORMANCE:
   - Pagina√ß√£o para listagem de participantes
   - Ordena√ß√£o configur√°vel
   - Pool de conex√µes otimizado
   - Reuso de conex√µes

3. üõ°Ô∏è SEGURAN√áA:
   - CORS configurado
   - Limite de tamanho de JSON
   - Valida√ß√£o contra SQL injection
   - Sanitiza√ß√£o de entrada

4. üìä RECURSOS ADICIONAIS:
   - Health check endpoint
   - Logging de requisi√ß√µes
   - Pagina√ß√£o na listagem
   - Verifica√ß√£o de nomes duplicados

5. üîß TRATAMENTO DE ERROS:
   - Tratamento espec√≠fico por tipo de erro
   - C√≥digos HTTP apropriados (409 para conflitos)
   - Graceful shutdown melhorado
   - Tratamento de exce√ß√µes n√£o capturadas

6. üìê C√ÅLCULOS:
   - M√©dia arredondada para 2 casas decimais
   - Valida√ß√£o de n√∫meros antes do c√°lculo

7. üß™ COMPATIBILIDADE COM TESTES:
   - Melhores pr√°ticas para mocking
   - Conex√µes sempre liberadas (finally)
   - Vari√°veis de ambiente respeitadas

SETUP DO BANCO DE DADOS:
CREATE TABLE participants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  full_name TEXT NOT NULL UNIQUE,
  age INTEGER NOT NULL CHECK (age > 0 AND age <= 150),
  first_semester NUMERIC NOT NULL CHECK (first_semester >= 0 AND first_semester <= 10),
  second_semester NUMERIC NOT NULL CHECK (second_semester >= 0 AND second_semester <= 10),
  final_average NUMERIC NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_participants_name ON participants(full_name);
CREATE INDEX idx_participants_average ON participants(final_average);

NOVOS ENDPOINTS:
- GET /api/health - Status da aplica√ß√£o
- GET /api/participants?page=1&limit=10&sortBy=full_name&sortOrder=asc

EXEMPLOS DE USO:
- GET /api/participants?page=2&limit=5&sortBy=final_average&sortOrder=desc
- GET /api/health
*/